name: security-check

on:
  pull_request:
    types: [opened, synchronize, reopened]
    branches:
      - test  # Se ejecuta cuando se crea PR de dev ‚Üí test

permissions:
  contents: write
  pull-requests: write
  issues: write
  
jobs:
  security-scan:
    name: security-check
    runs-on: ubuntu-latest
    outputs:
      vulnerable-found: ${{ steps.vuln_check.outputs.vuln }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Telegram notification - Inicio de revisi√≥n
        continue-on-error: true
        run: |
          if [ -z "${{ secrets.TELEGRAM_TOKEN }}" ] || [ -z "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "Telegram not configured"
            exit 0
          fi
          
          MESSAGE="üîç Etapa 1: INICIANDO REVISI√ìN DE SEGURIDAD%0A%0Aüìã PR #${{ github.event.pull_request.number }}: ${{ github.event.pull_request.title }}%0Aüë§ Autor: @${{ github.actor }}%0Aüîó ${{ github.event.pull_request.html_url }}"
          
          curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage \
          -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
          -d text="${MESSAGE}" || true

      - name: Get changed files in PR
        id: files
        run: |
          echo "Analyzing files in PR from dev to test"
          echo "Base: ${{ github.event.pull_request.base.sha }}"
          echo "Head: ${{ github.event.pull_request.head.sha }}"
          
          # Obtener archivos modificados en el PR
          git fetch origin ${{ github.event.pull_request.base.ref }} --depth=1
          git fetch origin ${{ github.event.pull_request.head.ref }} --depth=1
          
          CHANGED=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.event.pull_request.head.sha }} || true)
          echo "changed_files<<EOF" >> $GITHUB_OUTPUT
          echo "$CHANGED" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Run vulnerability scanner
        id: scan
        run: |
          echo "Files to analyze:"
          echo "${{ steps.prep.outputs.files_to_scan }}"
          
          # Ejecutar scanner de vulnerabilidades (incluyendo archivos locales)
          if python git_scan_commits.py --commits 1 --local 2>&1 | tee scan.log; then
            echo "vulnerable=false" >> $GITHUB_OUTPUT
            echo "‚úì No vulnerabilities found"
          else
            echo "vulnerable=true" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Vulnerabilities detected"
          fi

      - name: Parse results
        id: parse
        if: always()
        run: |
          if [ -f result.json ]; then
            # Extraer informaci√≥n del resultado
            VULN_FOUND=$(jq -r '.summary.vulnerable_found' result.json)
            FILES_ANALYZED=$(jq -r '.summary.files_analyzed' result.json)
            
            echo "vuln_found=$VULN_FOUND" >> $GITHUB_OUTPUT
            echo "files_analyzed=$FILES_ANALYZED" >> $GITHUB_OUTPUT
            
            # Extraer archivos vulnerables
            VULN_FILES=$(jq -r '.commits[].files[] | select(.is_vulnerable==true) | "\(.file): \(.prediction) (\(.confidence)%)"' result.json || true)
            echo "vuln_files<<EOF" >> $GITHUB_OUTPUT
            echo "$VULN_FILES" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
          fi

      - name: Upload results artifact
        id: art
        if: always() && hashFiles('result.json') != ''
        uses: actions/upload-artifact@v4
        with:
          name: security-scan-result
          path: result.json
        continue-on-error: true

      - name: Set vulnerability output
        id: vuln_check
        run: |
          if [ -f result.json ]; then
            VULN=$(jq -r '.summary.vulnerable_found' result.json)
            echo "vuln=$VULN" >> $GITHUB_OUTPUT
          else
            echo "vuln=false" >> $GITHUB_OUTPUT
          fi

      - name: Telegram notification - Resultado clasificaci√≥n
        if: always()
        continue-on-error: true
        run: |
          if [ -z "${{ secrets.TELEGRAM_TOKEN }}" ] || [ -z "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "Telegram not configured"
            exit 0
          fi
          
          if [ -f result.json ]; then
            FILES=$(jq -r '.summary.files_analyzed' result.json)
            VULN=$(jq -r '.summary.vulnerable_found' result.json)
            
            if [ "$VULN" = "true" ]; then
              DETAILS=$(jq -r '.commits[].files[] | select(.is_vulnerable==true) | "- \(.file): \(.prediction) (probabilidad: \(.confidence)%)"' result.json | sed ':a;N;$!ba;s/\n/%0A/g')
              MESSAGE="‚ö†Ô∏è RESULTADO: C√ìDIGO VULNERABLE DETECTADO%0A%0Aüìä Archivos analizados: $FILES%0Aüö® Detalles:%0A$DETAILS%0A%0A‚ùå PR #${{ github.event.pull_request.number }} ser√° rechazado"
            else
              MESSAGE="‚úÖ RESULTADO: C√ìDIGO SEGURO%0A%0Aüìä Archivos analizados: $FILES%0A‚úì No se detectaron vulnerabilidades%0A%0A‚û°Ô∏è Continuando con el pipeline..."
            fi
            
            curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage \
            -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
            -d text="${MESSAGE}" || true
          fi

      - name: Create issue if vulnerabilities found
        uses: actions/github-script@v7
        if: steps.vuln_check.outputs.vuln == 'true'
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            let result = null;
            if (fs.existsSync('result.json')) {
              result = JSON.parse(fs.readFileSync('result.json', 'utf8'));
            }
            
            if (!result) return;
            
            const vuln_files = result.commits
              .flatMap(c => c.files)
              .filter(f => f.is_vulnerable)
              .map(f => `- **${f.file}**: ${f.prediction} (confidence: ${f.confidence.toFixed(1)}%)`)
              .join("\n");
            
            const title = `üîí Security vulnerabilities detected in commit ${context.sha.substring(0, 7)}`;
            const issue_body = [
              `The automated security scanner detected vulnerabilities in the latest push to \`dev\` branch.`,
              "",
              `**Commit:** ${context.sha}`,
              `**Author:** @${context.actor}`,
              "",
              "**Flagged files:**",
              vuln_files,
              "",
              "‚ö†Ô∏è **Action Required:** Fix these vulnerabilities before the code can be promoted to test.",
            ].join("\n");
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title,
              body: issue_body,
              labels: ["security", "vulnerability", "urgent"]
            });

      - name: Telegram notification - Vulnerabilities Found
        if: steps.vuln_check.outputs.vuln == 'true'
        run: |
          if [ -z "${{ secrets.TELEGRAM_TOKEN }}" ] || [ -z "${{ secrets.TELEGRAM_CHAT_ID }}" ]; then
            echo "Telegram not configured"
            exit 0
          fi
          
          if [ -f result.json ]; then
            VULN_FILES=$(jq -r '.commits[].files[] | select(.is_vulnerable==true) | "\(.file): \(.prediction)"' result.json | sed ':a;N;$!ba;s/\n/%0A/g')
            MESSAGE="‚ö†Ô∏è Etapa 1: VULNERABILIDADES DETECTADAS%0A%0Aüîí Commit: ${{ github.sha }}%0AüìÅ Archivos:%0A${VULN_FILES}%0A%0A‚ùå El c√≥digo NO ser√° promovido hasta que se corrijan las vulnerabilidades."
            
            curl -s -X POST https://api.telegram.org/bot${{ secrets.TELEGRAM_TOKEN }}/sendMessage \
            -d chat_id=${{ secrets.TELEGRAM_CHAT_ID }} \
            -d text="${MESSAGE}" || true
          fi

  approve-security:
    name: Approve Security Check
    runs-on: ubuntu-latest
    needs: [security-scan]
    if: needs.security-scan.outputs.vulnerable-found != 'true'
    steps:
      - name: Comment on PR - Security Approved
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const body = [
              '## ‚úÖ Etapa 1: REVISI√ìN DE SEGURIDAD APROBADA',
              '',
              '**Resultado del modelo de clasificaci√≥n:**',
              '- Estado: C√ìDIGO SEGURO',
              '- Archivos analizados: Ver detalles en logs',
              '',
              '**Pr√≥ximos pasos autom√°ticos:**',
              '1. ‚úì Revisi√≥n de seguridad completada',
              '2. ‚Üí Ejecutar pruebas autom√°ticas',
              '3. ‚Üí Merge autom√°tico a test (si pruebas pasan)',
              '4. ‚Üí Despliegue a producci√≥n',
              '',
              'üîí Este PR ha pasado el filtro de seguridad con el modelo de ML.'
            ].join('\n');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body
            });
